## 문제 설명


줄서있는 사람 수와 각 심사대에서 심사를 하는데 걸리는 시간이 주어지고, 심사를 받는데 걸리는 최소 시간을 구하는 문제이다.

## 접근 방식

조건

1 ≤ 심사대 개수 ≤ 100,000

1 ≤ 줄 서 있는 사람 수 ≤ 1,000,000,000

1 ≤ 심사에 걸리는 시간 ≤ 10^9

파이썬 1초에 20,000,000번

최소 시간을 구하는 문제이니, 모든 사람에게 접근해, 심사대에서 걸리는 최소 시간을 구한다면,

최악의 경우는 1,000,000,000 * 100,000 = 1초 이상이다.

(줄 서 있는 사람 수 * 심사대에서 심사 최소 시간 탐색)

그래서 다른 접근 방법을 생각해야 한다. 총시간을 구해서 그 시간에 심사대에서 처리할 수 있는 사람의 수를 구해, 만족하는지 탐색하는 방식으로 구해야 한다.

나올 수 있는 모든 총시간을 대입해 조건이 만족하는지 확인하면,

최악의 경우 1,000,000,000 * 100,000 = 1초 이상이다.

(나올 수 있는 모든 총시간 * 각 심사대에서 처리하는 사람의 수 연산)

총시간을 이분탐색을 이용해서 푼다면,

최악의 경우 log(1,000,000,000) * 100,000 = 900,000 (1초 이내)이다.

(나올 수 있는 총시간 * 각 심사대에서 처리하는 사람의 수 연산)

그래서 이문제는 이분탐색으로 풀어야 한다.

## 문제 풀이

심사하는 총시간을 구해서 해당 시간 동안 각 심사대에서 사람을 몇 명을 처리할 수 있는지 구한다.

각 심사대 시간/총시간 = 사람 수

총시간 = 8

| 심사 걸리는 시간 | 2 | 3 | 4 |
| --- | --- | --- | --- |
| 처리하는 사람 수 | 4 | 2 | 2 |

총처리할 수 있는 사람 수 8명

줄 서 있는 사람이 총시간 동안 심사 처리가 가능한지 확인을 해준다.

만약 처리할 수 있으면, 최소 시간을 알기 위해 총시간을 1시~7시까지 다시 확인한다.

처리할 수 없으면, 총시간을 9시 ~ 최대 총시간까지 확인한다.

더 이상 확인할 구간이 없으면 마지막에 조건이 만족하는 총시간이 최소 총시간이다.

```python
import sys

input = sys.stdin.readline

arr = [] # 심사대에서 한 사람당 처리하는 데 걸리는 시간을 담은 배열

# 총 시간(time)이 주어진 사람(m)만큼 처리할 수 있는지 확인
def isAvailable(time, m): 
    cnt = 0 # 사람 수 

    for n in arr: # 심사대(arr)에서 걸리는 시간마다 처리할 수 있는 사람의 수를 구하는 연산
        cnt += time // n

    return cnt >= m # 처리할 수 있는 사람의 수(cnt)가 주어진 사람(m)을 처리할 수 있으면 True 반환

# 주어진 사람 m을 처리할 수 있는 총시간을 구하는 함수
def solution(maxTime, m): 
    left = 0
    right = maxTime # 나올 수 있는 최대 시간

    while left <= right: # 이분탐색을 진행해서 가능한 총시간을 구한다.
        mid = (left + right) // 2 

        if isAvailable(mid, m): # 총시간(mid) 내에 주어진 사람(m)보다 많거나 같은 사람을 처리할 수 있으므로 최솟값을 찾기 위해 
            right = mid - 1     # right에 기존 총시간(mid) 보다 적은 시간(mid-1)을 넣는다. 
        else:
            left = mid + 1 # 총시간(mid)이 주어진 m 보다 처리할 수 있는 사람 수가 적어 만족 못함으로 만족하는 총시간을 찾기 위해 
													 # left에 기존 총시간(mid) 보다 많은 시간(mid+1)을 넣는다.
    return right + 1 # 만족하는 총 시간의 최솟값 

def main():
    n, m = map(int, input().split()) # n: 심사대 개수, m: 주어진 사람 수

    for _ in range(n): # 심사대마다 걸리는 시간
        arr.append(int(input()))

    maxTime = max(arr) * m # 심사대가 걸리는 시간 중에 가장 큰 시간 * 주어진 사람 수 (나올 수 있는 최대 시간을 구함) 
    print(solution(maxTime, m)) # 주어진 사람 수를 최소로 시간으로 처리하는 총시간  

if __name__ == "__main__":
    main()
```

## 시간 복잡도

```python
단계마다 계산하고, 설명
입력마다 logn, 배열 전처리 정렬로 n
전체 풀이 시간은 n2이다.
```

main의 for문 O(n)+ main의 max(arr) O(n) + soluction의 이분탐색 O(log n) * isAvailabel의 for문  O(n) = O(n log n)

## 공간 복잡도

```python
사용한 자료구조마다 계산하고 설명
사용한 자료구조 명시
자료구조에 사용한 연산
```

## 어려웠던 부분 & 해결 과정

문제 접근을 사람마다 최소 시간을 구하는 접근이 아닌 총시간으로 접근해야 하는 점이 어려웠다.

사람마다 최소 시간 접근 방식은 최소 heap을 이용해 각 사람이 심사대에서 처리되는 시간 중에 최소인 시간을 다음 사람에게 적용하는 방식으로 진행했다.

하지만 최소 heap 연산이 처음 데이터 들어갈 때 O(logN), 정렬 시간 O(logN)이 발생하고, 데이터를 제거할 때도 O(logN) 발생을 하므로 생각보다 빠르지 않았다.

그리고 모든 사람을 한 번씩 확인해야 하는 점에서 시간초과가 발생한다.

총시간 접근 방식은 모든 사람을 확인할 필요 없이, 이분탐색으로 각 구간에서 처리할 수 있는 사람의 수를 구해 조건에 만족하는지 확인해서 앞 과정과 다르게 빠르게 처리할 수 있다.